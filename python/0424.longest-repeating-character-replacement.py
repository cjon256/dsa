#  Category: algorithms
#  Level: Medium
#  Percent: 53.44592%
# pylint: enable=useless-suppression
# pylint: disable=invalid-name, line-too-long, too-few-public-methods
# pylint: disable=missing-class-docstring, missing-function-docstring, missing-module-docstring
#
#
# You are given a string s and an integer k. You can choose any character of
# the string and change it to any other uppercase English character. You can
# perform this operation at most k times.
#
# Return the length of the longest substring containing the same letter you
# can get after performing the above operations.
#
#
# Example 1:
#
#  Input: s = "ABAB", k = 2
#  Output: 4
#  Explanation: Replace the two 'A's with two 'B's or vice versa.
#
#
# Example 2:
#
#  Input: s = "AABABBA", k = 1
#  Output: 4
#  Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
#  The substring "BBBB" has the longest repeating letters, which is 4.
#  There may exists other ways to achieve this answer too.
#
#
#  Constraints:
#
#
#  	1 <= s.length <= 10âµ
#  	s consists of only uppercase English letters.
#  	0 <= k <= s.length
#

# the completely wrong path I went down initially
#
#     def characterReplacement(self, s: str, k: int) -> int:
#         char_to_intvls = {}
#         for i, c in enumerate(s):
#             if c not in char_to_intvls:
#                 char_to_intvls[c] = []
#             char_to_intvls[c].append(i)
#
#         def intervals_to_length(intervals: List[int]) -> int:
#             spreads = []
#             gaps = []
#             start = 0
#             last = -1
#             i = 0
#             n = 0
#             for i in intervals:
#                 if last == -1:
#                     if i != 0:
#                         spreads.append(-i)
#                         gaps.append([-i, n])
#                         n += 1
#                     start = i
#                 elif i != last + 1:
#                     spreads.append(last - start + 1)
#                     n += 1
#                     spreads.append(-(i - last - 1))
#                     gaps.append([-(i - last - 1), n])
#                     n += 1
#                     start = i
#                 last = i
#             if last == len(s) - 1:
#                 # ended in the char
#                 spreads.append(last - start + 1)
#             else:
#                 spreads.append(last - start + 1)
#                 n += 1
#                 spreads.append(-(len(s) - i - 1))
#                 gaps.append([-(len(s) - i - 1), n])
#
#             # gaps.sort()
#             print(gaps)
#
#             return spreads
#
#         for k in char_to_intvls:
#             print(f">> {k} {intervals_to_length(char_to_intvls[k])}")
#

import unittest
from collections import Counter
from typing import List


#  start_marker
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        letters_by_freq = Counter(s).most_common()
        max_count = 0

        iter = 0
        while True:
            if iter >= len(letters_by_freq):
                break
            letr, ltr_ct = letters_by_freq[iter]
            iter += 1
            if ltr_ct + k <= max_count:
                break
            if ltr_ct + k >= len(s):
                return len(s)
            prev: List[List[int]] = [[None for _ in range(len(s))] for _ in range(k + 1)]  # type: ignore
            prev[0][-1] = 1 if s[-1] == letr else 0
            for i in range(len(s) - 2, -1, -1):
                match = s[i] == letr
                # print(f"{i} {s[i]} {match} {letr}")
                for j in range(min(k + 1, len(s) - i)):
                    if match:
                        # print(f"  {j} {prev[j][i + 1]}")
                        if prev[j][i + 1] is None:
                            continue
                        else:
                            val = prev[j][i + 1] + 1
                            prev[j][i] = val
                            max_count = max(max_count, val)
                    else:
                        if j == 0:
                            prev[j][i] = 0
                        elif prev[j - 1][i + 1] is not None:
                            val = prev[j - 1][i + 1] + 1
                            prev[j][i] = val
                            max_count = max(max_count, val)
            # print(prev)
        return max_count


#  end_marker
class TestSolution(unittest.TestCase):
    def test_case_1(self):
        s = "ABAB"
        k = 2
        expected = 4
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_2(self):
        s = "CABAB"
        k = 2
        expected = 4
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_3(self):
        s = "BCABAB"
        k = 2
        expected = 4
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_4(self):
        s = "AAZXYBABBAA"
        k = 1
        expected = 4
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_5(self):
        s = "AABABBA"
        k = 1
        expected = 4
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_6(self):
        s = "AABABBA"
        k = 2
        expected = 5
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_7(self):
        s = "AABABBAB"
        k = 3
        expected = 7
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_8(self):
        s = "AABABBAB"
        k = 2
        expected = 6
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_9(self):
        s = "AABABBAB"
        k = 1
        expected = 4
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_10(self):
        s = "AABABBAB"
        k = 0
        expected = 2
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)

    def test_case_11(self):
        # fmt: off
        s = "HOFOBTBYHGRGWLFCZTVTPVCNTDWKIVLMVMSCTFXCMLYAMPAUHBLAFTSUCBLJRJZBOWFVTBKOKNVCSTFZMPDILRHNXYIVNIYDTVEQPWGBQMHNDTVJBGPCHYCDXATCXSHDTKOFAVASLNVZZHGALSGXFHWECYGBBJKLNUMBTLQPDFVKOUYKPCVVQBBJLUIYOVDWZFDWGQOFSJGFXCCGOJYHLLOTKRRWPTWZIIXKWXAPJAQSHYMKZSGABRMPEWLZNURONELDVZDVYLGBZPPKLFYOJSBEVLMEZFEUQFOVISLWCTCUNLIBSWQJLBSZMHJHJFSVSVPTRUQYTPRTBLCBWTOVWBKLESBFSCRIODQKIBRSDBXETYONBMXQUDBDONRJQQBEERNDJWIWPBXHSTRKJTAAVCXELYTYQUAQJVARTKTGNNJHLPLCQRUACRMKLSCLMUPCAEJZGWACNLEXGQDVYRIZFCWPIBRQJNDPOBYLIAJDLAWZUIOZINPEEISKXUKDDPIHUVMOKRGPOXRMCQQUNXAXDFRUHKVKLJGIQSHUAWYXDFZAZARMZJTHOSIRRNCZKMYPSHFNIADJGPRDVTZVHDSXDEOABZJSNZHHVQFTWJAFVIMEBKVBBGGDWJUCZYHPYTWEXRYJSNKLBNPCHIZGELMGRKVJECLRFNCDGNXPDDIQFMRFSRLZNIIIJPXQESIQWLKDGKQSDJJTHEFQJWQPMYSCHOFFNPRJHZQLWTNCJHVSYMRAIDPNHPWDTVCCMXAKXPNZCJIEMUGWQCVRJOYJICNGYSYBKKZDADXPBHOEHJECEKTJKXMIMUOHRIOBOMHGKRKUQFCCMKFUVDPNOLAOVAMEGMHLPFGCSCOQDUZCKWWMEYIXUNDRRGHSUJFEYKVHHFEIVKOODHGOMJXGRMVTFKZJUFYSJNWSIBBUZZMIWNIDCMARWFKLQGIBOUUYOKOAKGZBBZUXZTDEXVFRXXDVPLVKJIOUUDXVFRHLGUKPJDGOBSXIOWJWOICDIRJISYWOZYINRCMIZDYPQTJXYBRKXJFPIQFXGJSCWXKHYISKPEZOGDQXTWJJTNVMLBHCGPUATVOHNHCSZWSABTNOVAAJSFYTZSDSVNKDTEJOMWEMCASYRXCMNZEZDNQQWVRUFFNWOZEMIPXWMODSPDLXUYBNOXVZZYJTWAFGORAOZOMLHCTKUVHVQFPZSCFEUVTNCPQEPJHXYDKZVSOIXLHXMKHXOJFBPBKFQOSRTXLLJUJBHSIXMZGNKCTJLJVLHNOAHICPSHBGVATTJGBNQVJVAKAPGQWBUHVPVPAJJJJGRYFHZGIDTNNPXWCCFSBBYEBIXTESHYVLXCKICCWWHJMUXJXZYBIEORRQGWFXCTRRXKEOYQEBZGQJRMODERYSZTHZRJDZQTLCDFCYHLIUSXWGKDHBJDFGOALSHIAUDKQDZYDWFPRMCEYZBKMZFURIGRVCKEXGHSQEWLATVUHAPCZNYYUUOSTCATUSKWGMSCCBBYREQPXYPHHZHXWWYARQXNRNYMRKNVMTSXGBTPRUZMWHBZJPVRLLKECEZUGFBVYTWYTJAODDNQEZRFRMDWUWDISMTXANVYSRICNEPHLSQKFVQKYLBKZZZBSKKKVPRMSSTBCVRWFSPEKFPUICKNNTSMRRIGAFJHKBRVAAVWVYVCCDPVAUSBSETLOZVGZBAVZSOYUGYHVRWWKQXQJNCJNEZPJIABYVVEEGOBAZVFAWTCKLTFNQDVCJEPAUDWUPTETTGMWGNDMBGBSSVNBSIIQNWLXFUTWLIZQQJAYYRARIMUZPIMDOQMATXJVAXDXDHLHKMERUMJJFGJGCZVZSJXQASVTJIPURMALABCTQZQWAUNVHUEVBGTGVCLALCBLDUBDIZPFFAZDPRLKJTLSYQDLUZDPOWOIUYLQHVWIIYYHASUKWDXAFBDYUQUXLZYULMYFFLXKZTFHBEFIGUWUUYLJVXKMIQVFGTJKUNGPQHLXEMRHBUUEYVWMSOWZURUSEKZBTLZXTWCXCHUSBYNIVXBXUWTEAAIXXLUZXLRYRDNETDRBYJOAVEYUQKPOTDJZFBTTMJAEGRQTVWTRZPJOVAIGPIEDKRHVRNMEILXFMFODLNIVSMHZWZHEDMANFSMQNBPQCMRXOCWVNZIQCFDNSZJLTBUAVCIKVTQRXWMXWCSNTVPWAGXCRGRBGMMDNCLFRSUJZAYLVJAZITZPFHCCKXERAWKHZOFETVXWCASLWSYISVBSAAIMYNCGHYFACMSUCBBBVFTPHQSSGNMNPFJCMEFOVDXBOZLPCTBFWLYRRWYNWSAPZFZGBHBKFGQBBJOZBGXDYNLPDRPDPMIFDVTXGELHHQLXQPQVPQAETJFEQZQNRZTVJKIWZKLXMZUJSEJOSSYHRHKOQPUEWKMYZVAVPXCLWMCNQCDDTSRWYNTCADUXHECSZJTDUVYZBJJWRKEQHMLSTGEKAAUPPJKSLCOZTNEFWLQPXQEPWTDMNMVJJZRCIFCLKISBVYZGHNTYMPXLFIOPAIWAOLBOPNSKUDNQTJNRSPNCXVCQEDFIFGGNUTDLNSXNMZUEJSYHKIGJVPGDRFCLOTKOTZVGYYEWCQHKLCAIXTPPXKBPYRZLRGLTCLZVJVNWHMVNMFBEWHMYNUZEGGUBCOOYWWPCWIQCXAEADUMGBOGMWEMYBDVKEGCVPZBHSXFXGVXPESNIIQMPBVOLHYQXFECLBMBTHFVQUIPFKCCQPGYITHIUTDGSUILWJLSQAOWMRHRMIISZLJLLDKEQQYDEIHQUHCTWCROTPDNSKAHOTWJBNNDHTJQENHHLRDRXFDLBZROHSDUWSIWIRWMJMBAFMQZCHLNTICCGRHCJASITTKWRDMDOFYLXVWFDERHKZPRWNBDRULGECPAGVIYDLELKGJLYDKKLEZDJLVGUMOYMQPZPBHYCPUDJHZFQGSUXHRDOWLPHLPUQUHXUGGVYXWFYEZTRTTUOMXKFRWPZGSWBWBOLHUGJWCZBDUYPVSBDLWGVSFVNWCKWKPNDNWGSRXSGGTBTENPSHXJNGBQZGEYANMHTRJSUBFUAWBBKNKJARTPLNONISBLZNKRMYOLIUFPGOKWELTGEXNHWQRBRXUCANFWGREUBACBBSLGMRHQMIHMKOMTTVYLYVVEEQCSFQAGLKJLPJSFGQRDUALJLHZAMTMAQZZMEAFYNJBFFWYVNEBALNKSJBYQDXHXNHLHZVLZVAZKSYXLOITOGKZADPGIERNYMJNYEJSNOIYHQSRUKYBCQBLLDFGZEWUEIKAPOGNTPNWERPEBAXBJSFIMVFJJLABRQUUJUGIQXCCGZAPJKNJDCLNDSJXVDBEUNYHLWTNTQCIGYQXUMAFHRJMJZDXXKPGOOQZZAJDDALYAUPBBKPMUYTEYOUVIKTOFEOCBMXOCHHBMTCFQDVXTOEYICKAYPZTSDYKIXDKGGQCKMEGGUYQIDRRHREZKDTXVEQIUWRNKHZKPWYIPLVUGXDLGRWVNJNTZKKIVJEDTQCUSUYLQUXXRIRMHXSPXYHBIGLVJDDJVEOFTMOGNDQONTPNEXAEQYSHSBBKCHKZMAWVVZRXVUPBBZNPRLSOBCLTBLYHRPAEICKSJFBDETIQVAUKJRBRHYFHPRQQEHRTWASWEXLAWBCCSEIERTLBSDEJJAGGBGRYSKNPFOAPZIJUWXHFKOGYSCONWGVSKYBBXCVKXYFERSXLGOOGDDYKRSLMKBOEQNWMLDNQEMFOHWKOBVEMCUZKDMOYGCDSEPRBQTZEEBNQLMAJOCLWEKBRYBGUUDODAQVBAVJHZYKATHCDUWLBWCPPADYOYQFHLPLPHRKKPOVWHGBFVYUEYSUJWTYHDJWHRZHBVSJDTAVVWRLVWISJSCRAUYZGBVSKWOMMXUXHBIBRYAFMNLDKCNHCRMVGVZWJGABDEFOMOQXGVJPNQQMGHXDXUVIBRHPVBKHUGOPABYPXJKUNBUWDFSWUPCIZVXMRDKLKAVZXQYIBUWOQICOHIGGSGWTNJMHYLWRLNJMZVXJKFLZPUFQJRXPCXXDJWXGLSGKNPBPFGIVRCTOPIRWNRGWNPXDTQLVBZOSCTPSXYRWNYYSQNFAIZMPQSHLQMNUFUZTFPFCNCFITBZLXHJAUGSMGDCGMUGUKRHYNLVUQCPSFSIBAKRGDOEMGNKESLSKAUUACPCDSWPSYECBEHJKIFKWVGMARQXRSJILQVJHPGRUHUCDRBELHYNTEDKLXJBEVVAQPJPRVAJALLROATXFSOLLYFSSHINNHTIKSBQVHEEHTPVVMWQCPWPJBLRPAXWSGRWOJCUOXKZZTRBXNELGEPHXNMWPAWTMHPSSBSXEYFCPOABRWKWVPKLVRPALBHBZPHORMVTDYYODTDYBHNFXEASARUUTZILRHFNHCRZEYNPZJENUONXLUBMDYGJOSIBGAPUAVFDXOZUXPAESVOLCBOMIGJNVYVVBFOXXNYSJOKQMGTBKXCDQXWOBRURHSTRQBEMMHKDTXKPBRMJLBXDGBMOECVEBVDSFNFTWPYXHRFYRPCNRFKBYTDGXYVOHSIWMNLLIJJFCGAFKPLJPHKRVISDNLFZHMYILNJJBRYHXHPXJAHPYQKDYDOWJQDFCTYLSHDJKXXKKZXBKDNVNVWYAVCFANDZAUDTLEOUVMMUOSPBDJRQKMBYWPVATPIAZXXSVLZGCNQHOFGMPFYGNTOOUYJYCLWZPSDNZSDKXPWXNGCOGESJMELGVHVGUAYMIRBUNBSKBOWUEJBDLCORYZDXACHLMJVMZGPUHHNFYEATEMBSNVXRJAWBVLUIXZNQZVZXAZIVDQDVYAHTROHQNCNLYBPOJVXECDEUOLYJELHTXJWNEYEWRKFWLTCVSBFNSLYXFKXCWBYWFCOZDFMWQGOIDOLFGWTVQNUZUJVOQZGDIGBIUTHHLHKRATRNHROPINPFWBEITQCCRJBDNBEROGOOEXSLWSBUFOWBHHBKOMPIKJSDIWNFPEQSAWUCMVTLPSSSMTSWRYFLRCMDZCSBQGSEYHILMFSRXMMVQRLBLIHUYQVGFWIIQOBIPPAIMVCFRPKLFHDVVAOXMIWJYZKMTJCYUAOUTSORZLNDPGBRQCSOVRFCHPOSJJKASCKXCGWHSIWLOGPAIRNPMKFKISVFQEXIBJFEFYOGBMKNMAIRWIDJPORIZYWWCZPVPPRMZENUTXQUPWBZQVTKKOOWSXPWWZUQFOHEVGLLKVSSVDCZVQHSVFJGUAAXNVGGCPVYXZNITHVAQVREROKIQFDUWNTSMWKTLRFOGFDIYHWAQNFTXGQRSJKKMVLQEDMLLEDGHWOZHHVYHNUSLELHOOJSAWMLVFVXDZKFUGDCZRANDBVSOLAOOKATMWLHKDNCAUAHTUTLZFGVDEBFHOHWGODWAWPDUELBBJOXPBQMPIMHLONVYJNEXJFQLIGNPSTMZSEESOHMRXDHTUDMWUFFFFVRTSLVEIPZLCBMHMQJDZRKDKFMYPMOYEGRJDPSSJQOXHXSWTGVKBCRFVQVLUEDGYYYFWSOORFQHYNDIXDMJKMRWBOKGITRTBXSFAMTTHHCKFWCXONRKYUFIZFAQPKLNKCKVZMKUPWWGZWNUPYJZXLPBCCJXUKYZUHITLDJMBKUOPHAGMJOZIDAYIBKOXZROYVVWSBEZDJJPSHIVFLEXECRWYCYDQCQSFNVUHUIROMHXHLWELXVBWXJHHABGVGSAMYSMCVWZMQVDOZNJVKCYMZDEVAGPGINZYRDTOPYNOQFBHSQTBVSEHLKEMYAVAIPGRJWGOKGEVDAHOMQHOIVDIJJUGWRXIKVEGOZXXATYKZGSAJJRDPDQOSFZYQRDPEWBCXMBTFRWZMCXSRVYYGPWVQYEVYEYGSCMIMMJEKNHMFITVRVESVRMHNJZOBVUXFUEZRZXEMZAJETKACLUOMNSILVGZUDGMMVHRQJCEVQCNUDIPLETUQEFNFRSPBNSZPZGPFBXLYDCVXSHBNJLSZDTNFRBHZWBNGOEAWPLSJICGIYLYVMQNECNRGVUDFHZQTZFECVXJRPDTLYJNYRBZKHZCLDKRKFPFOTSMEWGHLNBOPREBCKKZQHWOSCMCALHWRQUIUPFXQQDRIYPHEGQACEGVUPIHXWRNZFKAQUPHRKQOGCMYKOSPYOFFWTLWIXNPENYSUOZFGBFOFDXKAZWYPMPZBIYDUQTUDRMIKHPXKVGPLNHKFVDVBQRIPNMIBVFQWLFIBNYWWPXCHJUIZQRUQLVUJKSINVZVMHZVQRUFQHLAVKBKWRRFSTXGGXLLTQYWIKOOJKTDNEILIDHLSDDCUUIXKGGOIGOWGUJNKEYQTOXFSIYDCBZNPNOCHIDGQRQRHHWSMQWIHVEHFJCTPWJYLBCREAGVAWRWXAQTUNQRPIZJNYGBHZRBSSJHKFIVGJGECNKTHZNCJJZKPEDBJGSDDGHNZZWOMQSKROMELMUTXDMRTMMCUDITKDTCRIVASCJGZIKEAYURAJNRXJBDNSKJYAIKQIPNPCXZPTFXSAMOZSNZRIVVZUHTEKJHJDHXHWXBTOEWRRCDJFNXLLKWREMNGGJSEGVYVUNEPFXJLLXERBXWXWRXTVNZXDRZYQYBSRCZJEEIRXOPNLDQCBJEHRMRJCGFWRKJXBHCBWOVECBDWBPKZJGCUTUARBABISVVGBPGXGQKAZWYQJMYLGECUZBGEGMKEPHLBQGXZKJKVYDVIOTHCGQLHNBZUFPFTNEGQNOCMCSQICSKGGIGQDGEKRWZMIGNAAYPKXFYAFGKHGXXZATQBOAYKAJMKHPUOYOMBZVXUZZXFJAVISUFKKJQHVWQYSNQQPZJWSFYLBUOPPRIKIEOZQBOWVMDZTMMCVYJAINXTCEWJKAEPWCLPYWMEAKHKEWHKUIFQYTOBMDHRPFCXZOUWTQFDWQPXXYGGSQJISDJXQGSSPPRTXYKZBBZRTPJCIXZMVXAJLJESMDIMMNKQRCIVRBGWXRVJKIQBUYFFJRWEGUEJPGOTQGZOWNCTNKNABGGOTHHVJRWIAFCUHWLCZGUHZMUHHFOHCJVDFWCRSEMQUIXANXCVDJXQMIUCYGLVXRZJFAVILYXGYRWJCHNRMCSHACXXYZKHERFKXERVKRZZGGEKKVLKOBJSTPVXXDKNKEBQHWMHFLZYHISBQVTAWWWUCUUDVTUJNGIFKYUSSBRANAFKXCVCNDICEAGCBMYPEPAKXKIXHCSHPUSBDXPCYLMYCAEEMFPHHBTKZMJSVIFSAHBRQDAFHNIRBRCIPHERLGDBWAXUEAEJTPLRWSRTBQHMAFLOXEKCCNYULESFLEPHFGHXGEPRUVZSSEPROWGQZYGBVIBHXGRVYGLKGBPAXCYFNUFOZUSCNIUXAAJATAJQOZCLFGRSDOXWCOGZOFAZSPOCIDFJPYWONMBZQRAEXSSWIIZQJKSLDFQMNTLAGIWAWERODWJNFALCFOEPMAJQNTPDDWXJRMVULWBRHKFUYZEGYKWTSIBFHZMKMGFPVTGCCTTLGUNWDTZMDOPQQNUARSTVNCABCTJUCRCJVBBRKHJRSWUKSFFMVLTGDZTRAONWUALYRMQQPUTWEGVPWFUHNEYFGQHFAJCIRCDEPOGLEOSHYPDHACVHSBYFQFPSQVBABUWUVPTEWZKXIVTSEVICFAPNCRFURJCAERQPGQAEDWMPHWLIVLWWRTVVRTJYDNUVILRWFWAUQQTHWSPCMUBQOUCARJKFDYIPZVBFFBCLNTCHWKSGIQPVHJKEBHSEXEMFSSOGBILSQTXZTYIAGSMNUOXIUHJOEKONJTXSNALDYXFURJCFEAHFNFHADFLXFIMVPXIKHDFPTKXDCZMMEDFQGZFKOPAMXZHDIWENUGQJMGMHOXCCJWWRGTYPMRBVTCORIHYOMFTPMNJQCDCANUVKWLPDZJYDNTOPMPSNEZHHMJKLTGVUXNEJLZPOXLENESNWQESIJJQZAKISZMWKHSBLWFKOCLAJVFKSXVZBBDDHHEHMGXKPOVADQNZZIRBEYOSBILMKFRROVJTPUZEKIVMUTFMIRMCXXTOWRXQGGDHKCPQSTSPTUIAMCLCSLUAOXHNPOEGYCVMHVTEQPUITRIUKEVIDTAEWBTMCMIGWOVKNPNLIPBBKRFORNOGTYDJEGRALXQEOEZIYRPDVNITXMVGYAQLJFCLYFFFPSMZKBBYTEFPOEQTYUSPKFHAJLEUVNMQXXQSIRWPYWPOQIPEWDNEZCFIJOIJNJKPHWNFRUZZRGSRKCHHTIRXMWHIZCGXRVNXDNNYKXDVHMTIGHFLDWPFKNFTYCVHFSJODTREHZIOTNMWDWFQTPFMLVAXTEKFOJISLRMEKHXAHIYJVXQRJZZICNDCHDUOTYXMZEWNFOJVGAXQYXOAAIYEGCEBZCCTYZUMNLGBHPNQHMHEKUSFEBMOIZUHWEWGYCTBLNQILCXIQXDLIOAZUYBNXDRAFFLMXHKURBXMKNFTXSRWDIMCEOBGHBZNIFIUTODWRNERKSJKGZMKMSAUMSQPBWDPMWGTMXJLEGQVMFXFVUAWRUHQNSATDJHTNQJSYTTGRZWBIBEXAIEAOYFHWPWFCGLBQKKMCREJMESFXNQRUJOOLOJQTFOKFQQUHPDVYUEZLVTYLEZAHXELYNVKLVBYKDXIDYYXAMHSYRTPYZTHPRIQLXZIZEOGVKTEUPETKSAQASVKTZBKDSMCKWUYWUCUWOBZRBUYLMBRUUTCJTDZKUMARTCPYNCUNWEHLBJDKTLSFZTKJAKKNBRZWVUOSEXVMNYNEIMXSXDDRTYXATZYQTIJWIDUSFZQDWYNQVPTKYSUGTNUMHMOICHIKOSEJPYIIHNGRZLDBUZEOUCVTDHFVKFSWLUXRMFQWZWSXMOGUUMJICOWIXVALCIYXWLNQRQXVVJNPBZCWLTLSLSFXOPJZCXKTNNPAVWNZNTGELVEGFEPOKKUHRYEYCSZJNILBEDMBWWGYEHEOWNPCPQRNDYVIONZWWUNJBFAMKLVEUJMRJHIXEHICHWZUKHSHFTQABAFFIIKJLVPUCRPWPEMPVTNEKKDMSGPHBSCTABEVUNLQJMEQOOYZJQOFWGSSAOEONUSBXNIJODNYOKXSSZJLCWEOJQRWXVOVTYLHUVPCUJKEQBXELLMTKLTFHEXYIZOOMIAHFFZEWUFYTHJFZQPLFKEBMXYZMJDFFNSEUEJZVPYGOBEJTBODCBBPJBGSUOXWYARAZZFKQAPZKPAKUFGGFMTNSVXEMNJGQLMDYRWIGAYMXBKOBLIUYWXYQLPVZJDXXAYMRMFPFPDEVNTNQXHCEYKDMHCCHAONXJFPDSUNYVQPJIGMTTNVKCCEBZGVEXIBBKNJNEXVBHCBUUDUEHVYCTKDLEZIQZQUAYITFHNKZBVFROXIWHZVGFVEIIEYYSDENSQIHVDEUKTJOGWUPENUJRMPEXWFFVMYEFSVRLQKADWFGEWCSBRBYMKPJCOANOUGWIOEEOVBCAZISUWAGBIIMHIUPFPNDZHJITWIEFUXYGGROCNNRWCEXWXWFEEQRWGEERRUIMJJIVIKKACILJXXRERPWISZQDIRPMSZYUKWSIDAULUBHCFURFBRYBJDNQQVFOXYMWIWHLAHDDZHZEUYDDBOMFQNOVIKHOIYWDCHTDYAYOKXLSJMIZDROEKYBMBACXHPPDCAGFKSRINFCXMOPDDFZUYRPMZUWWNDVNECGFHIOEJWXPKCQQUEJKWPDWXXWVSPVOFDKKSZJJWZIYOXKHQUZFQFVFQUNNLDQKIGDBNPPWUDMTHUJISNKFFTSAAULJUQWELVSPUNTYMPCENZKCXVNDTFYXFFSFKGLOVENZKRGHGDHNTNZWAMUSPYJAVOUBGJWLTSLFAKBUVWCVFJGEQFVQPPCEEAKRYUTRLILHNXZUZDUDJYXKMBNJJRQSIDGODKZSFXTFLXSDPECDVGWVCXXHCRIGZWERXJQQYRLVMUTFZBKFNOFBWRBMKEECUIDU"
        # fmt: on
        k = 1000
        expected = 1065
        result = Solution().characterReplacement(s, k)
        self.assertEqual(result, expected)


if __name__ == "__main__":
    unittest.main()
